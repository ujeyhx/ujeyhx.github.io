---
title: Why Jekyll with GitBook
author: Tao He
date: 2019-04-27
category: Jekyll
layout: post
---


# 5/4

ch 6 큐 , 2021 알고리즘 큐 

ch 10 검색 ppt , 2021 알고리즘 9 검색 ppt  (ppt 두개 참고)

큐

~~

검색 

순차검색 , 선형 검색 

```cpp
#include <stdio.h>
typedef int element;

 //정렬되지 않은 자료 

void sequentialSearch1(element a[], int n, int key) {
	int i = 0;
	printf("\n %d를 검색하라! ->> ", key);
	while (i<n && a[i] != key) i++;
	if (i<n) printf("%d 번째에 검색 성공! \n\n", i + 1);
	else   printf("%d번째에 검색 실패! \n\n", i + 1);
}

void main() {
	element a[] = { 8, 30, 1, 9, 11, 19, 2 };
	int n = 7;

	sequentialSearch1(a, n, 9);  // 배열 a의 n개 원소 중에서 탐색키가 9인 원소 검색
	sequentialSearch1(a, n, 6);  // 배열 a의 n개 원소 중에서 탐색키가 6인 원소 검색

	getchar();
}
```

```cpp
#include <stdio.h>
typedef int element; 

// 정렬된 자료 

void sequentialSearch2(element a[], int n, element key) {
	int i = 0;
	printf("\n %d를 검색하라! ->> ", key);
	while (a[i] < key) 
		 i++; 
	if (a[i] == key)  printf("%d번째에 검색 성공!\n\n", i + 1); //찾은경우
	else  printf("%d번째에 검색 실패! \n\n", i + 1); // 큰 경우 = 같은 경우가 없음
}

void main() {
	element a[] = { 1, 2, 8, 9, 11, 19, 29 };
	int n = 7;

	sequentialSearch2(a, n, 9); // 배열 a의 n개 원소 중에서 탐색키가 9인 원소 검색
	sequentialSearch2(a, n, 6); // 배열 a의 n개 원소 중에서 탐색키가 6인 원소 검색

	getchar();
}
```

평균 비교 횟수가 반으로 줄어듬 ( 이미 정렬이 되어있음)

---

과제
** max 값 define 또는 직접 넣어서 선언
** printf 문 %d 값 없으니까 추가해서 넣어야됨

![5%204%2026773f612b904ce1b50c449b536ef895/Untitled.png](5%204%2026773f612b904ce1b50c449b536ef895/Untitled.png)

공통으로 입력한 값 있는지 찾는 알고리즘

```cpp
#include <stdio.h>
#define MAX 10

int main() {
	
	int a, b;
	int u, d;
	int UP[MAX], DN[MAX];

	printf("첫번째 줄 입력 데이터 수 : ");
	scanf_s("%d", &u);
	printf("첫번째 줄 데이터 %d 개 입력: ", u);
	for (a = 0; a < u; a++) {
		scanf_s("%d", &UP[a]);
	}

	printf("두번째 줄 입력 데이터 수 : ");
	scanf_s("%d", &d);
	printf("첫번째 줄 데이터 %d 개 입력: ", d);
	for (b = 0; b < d; b++) {
		scanf_s("%d", &DN[b]);
	}

	for (b = 0; b < d; b++) {
		for (a = 0; a < u; a++) {
			if (UP[a] == DN[b])
				printf(" %d 공통으로 있음 \n", UP[a]); //값 넣을것
		}
	}
	return 0;
}
```

1) 함수 호출구문으로

2) 각 배열의 몇 번째 요소인지 출력하는 구문으로 변경
공통으로 있는 요소 몇번째 인지 출력해야됨
4가 배열 a, b 의 몇번째 요소인지 출력하도록

![5%204%2026773f612b904ce1b50c449b536ef895/Untitled%201.png](5%204%2026773f612b904ce1b50c449b536ef895/Untitled%201.png)

![5%204%2026773f612b904ce1b50c449b536ef895/Untitled%202.png](5%204%2026773f612b904ce1b50c449b536ef895/Untitled%202.png)

```cpp
#include <stdio.h>
typedef int element; 

//참고해서 함수 호출식으로 만들기 

void sequentialSearch2(element a[], int n, element key) {
	int i = 0;
	printf("\n %d를 검색하라! ->> ", key);
	while (a[i] < key)  i++;
	if (a[i] == key)  printf("%d번째에 검색 성공!\n\n", i + 1);
	else  printf("%d번째에 검색 실패! \n\n", i + 1);
}

void main() {
	element a[] = { 1, 2, 8, 9, 11, 19, 29 };
	int n = 7;

	sequentialSearch2(a, n, 9); // 배열 a의 n개 원소 중에서 탐색키가 9인 원소 검색
	sequentialSearch2(a, n, 6); // 배열 a의 n개 원소 중에서 탐색키가 6인 원소 검색

	getchar();
}
```

```cpp
#include <stdio.h>
#define MAX 10

//최종

Search(int u, int d);

int main() {

	int u, d;

	printf("첫번째 줄 입력 데이터 수 : ");
	scanf_s("%d", &u);

	printf("두번째 줄 입력 데이터 수 : ");
	scanf_s("%d", &d);

	Search(u, d);

	return 0;
}

Search(int u, int d) // (1) 함수 호출 식으로 바꾸기 
{
	int a;
	int b;
	int UP[MAX], DN[MAX];
	
	printf("첫번째 줄 데이터 %d 개 입력: ", u);
	for (a = 0; a < u; a++) {
		scanf_s("%d", &UP[a]);
	}

	printf("두번째 줄 데이터 %d 개 입력: ", d);
	for (b = 0; b < d; b++) {
		scanf_s("%d", &DN[b]);
	}

	for (b = 0; b < d; b++) {
		for (a = 0; a < u; a++) {
			if (UP[a] == DN[b])
				printf("UP[%d]와 DN[%d]에 %d이 공통으로 있음 \n",a,b,UP[a]);
//(2) UP은 첫번째 줄, DN 두번째 줄 인덱스 출력하기
		}
	}

}
```

---

이진 검색 , 이분검색, 보간 검색

 

정렬된 자료에 대해서 수행하는 검색 방법 

중간에 있는 값을 기준으로 잡고 

찾을 값  /  기준값  비교  ( 크면 오른쪽, 작으면 왼쪽 ) → 계속해서 기준값 변경해감.

기준값 :: 배열의 중간에 있는 값 ==  // middle ← (begin + end / 2)

** 재귀함수, 순한문 두가지 형태 코드 있음
